module MartingaleMartinLof where  -- no exports qualififcation, so all exported

import Data.List  (union, transpose, sortBy, isPrefixOf)
import Debug.Trace (trace)    -- DEBUG
import Data.Char  (intToDigit) -- digitToInt
-- import Data.Typeable (typeOf) -- DEBUG
-- import Data.Set (toList, fromList)
-- import Data.Foldable (foldr', foldl')

-- For the following, need to load the libs in the stack setup, or 
-- run ghci as something like:
-- stack ghci --package pretty-tree  --package containers --package random
import System.Random (RandomGen, randomR, randomRs, split, mkStdGen) -- package random
import qualified Data.Tree (drawTree, Tree(Node)) -- package containers
import qualified Data.Tree.Pretty (drawVerticalTree, drawVerticalTreeWith) -- package pretty-tree

import BinaryTree -- my module


{-
Code to help verify/understand part of the second half of
Downey and Hirschfeldt's (2010) Theorem 6.3.4, p. 236, which is their
version of Schnorr's theorem that Martin-Löf randomness is equivalent
to randomness defined by computably enumerable martingales.  In
particular, a set of infinite sequences is Martin-Löf iff it contains
no sequences such thagt a c.e. martingale would produce infinite
profit betting on subsequent digits of such a sequence.

In particular, in the M-L random -> martingale random direction of the
proof, D&H give a method for constructing a martingale for each set in
an M-L test.  The construction starts from the fact (Proposition 2.19.2,
p. 74) that every computably enumerable set of infinite sequences can be
generated by a computably enumerable prefix-free set of finite
sequences, and then the construction specifies how to define a
martingale function d_n for each prefix-free set R_n generating one of
the sets U_n that is part of a given M-L test.

The code below constructs the values of d_n for a given R_n.  D&H's
description of d_n is terse, and I had trouble working out why d_n
really is a martingale.  This code allows me to perform the
construction, see the result, and better understand why it creates a
martingale.


Example:

gs = generateGeneratorLists (System.Random.mkStdGen 524) 13
np = removePrefixes $ take 20 $ gs -- The arg to removePrefixes must be finite.
mt = sumGeneratorSet np
isMartingaleTree $ takeTree 10 mt
drawTree $ takeTree 6 mt
drawVerticalTree $ takeTree 4 mt

-}


-- TODO: maybe actually define the d functions so that they can be applied to inputs.


----------------------------------------------

-- not test data; these are essential
zeroPayoutsTree :: Tree Double
zeroPayoutsTree = Node 0.0 zeroPayoutsTree zeroPayoutsTree
-- without cycles: zeroNodes _ = Node 0.0 (zeroNodes 42) (zeroNodes 42)

onePayoutsTree  :: Tree Double
onePayoutsTree  = Node 1.0 onePayoutsTree onePayoutsTree


{- |
'lowerPayouts len' returns a list of payout components for a generator of 
length len.  The first element corresponds to the empty string; the last 
corresponds to the position one less than the length of the generator.  
These are payouts correspondng to the string up to that point.
-}
lowerPayouts :: Int -> [Double]
lowerPayouts len = map (2^^) [-len .. -1] -- from D&H: map ((2**) . (-len_s +)) [0 .. len_s-1]


{- |
Add payouts for generator string with lower payouts to tree.  The first payout
corresponds to the empty string.
Examples: addPayouts generator (lowerPayouts (length generator)) zeroPayoutsTree
          addPayouts "01010" (lowerPayouts 5) zeroPayoutsTree
-}
addPayouts (g:gs) (p:ps) (Node x next0 next1)
  | g == '0' = Node {payout=(x+p), nextZero=(addPayouts gs ps next0), nextOne=next1}
  | g == '1' = Node {payout=(x+p), nextZero=next0, nextOne=(addPayouts gs ps next1)}
  | otherwise = undefined -- no other characters allowed
addPayouts "" [] _ = onePayoutsTree -- default case when lists exhausted
addPayouts _  _  _ = undefined      -- lists should be same length, Leafs not allowed


{- | Convenience function to addPayouts to a tree directly from a generator -}
addGeneratorPayouts tree generator =
    addPayouts generator (lowerPayouts (length generator)) tree
        
{- | Sum payouts from all generators in list generators. See addPayouts. -}
sumGeneratorSet generators =
    foldl addGeneratorPayouts zeroPayoutsTree generators
-- to use foldl vs foldr, swap order of args for addGeneratorPayouts

{- | Transform each generator set in a list into a test tree. See addPayouts. -}
makeMLtest :: [[String]] -> [Tree Double]
makeMLtest generator_set_list = map sumGeneratorSet generator_set_list

{- | 
Tests whether node satisfies the martingale property, assigning equal 
probability to each branch.  In other words, is the simple average of the 
two child payouts equal to the parent payout for each (non-Leaf) node?
-}
isMartingaleNode (Node p (Node zp _ _) (Node op _ _)) = (zp + op)/2 == p
isMartingaleNode (Node _ Leaf Leaf) = True -- OK for a truncated tree
isMartingaleNode _ = False -- unbalanced (?)

{- | 
Tests whether a tree satisfies the martingale property, assigning equal 
probability to each branch. In other words, is the simple average of the 
two child payouts always equal to the parent payout for each non-Leaf node?
This obviously won't work with infinite trees.
Example to show that the first 50 test sets for martingale repreentation mm
of an M-L test are martingale up to 15 deep, each:
   take 50 $ map (\t -> isMartingaleTree (takeTree 15 t)) mm
Remember that increasing depth needs exponentially more space and time.
-}
isMartingaleTree Leaf = True
isMartingaleTree top@(Node _ z o) =
    isMartingaleNode top && isMartingaleTree z && isMartingaleTree o
-- Note can't use fmap in any obvious way here because it maps over *payouts*,
-- and this function has to map over *nodes*, since it has to get the
-- next nodes as well.  What I need is more like a fold.



-- Folds inspired by Data.Tree's rosetree fold, but the function argument here
-- operates on nodes, not node values (payouts).

-- v3:
-- foldTree f = go where
--    go n@(Node p z o) = f n z o

-- v2:
-- foldTree f = go where

-- attempt to define isMartingaleTree in terms of above foldTree
-- ismt Leaf = True
-- ismt node = foldTree f node where
--    f n ns = isMartingaleNode n && foldl ismt ns


----------------------------------------------------------
-- Convenience functions for constructing M-L tests

consOtherDigit initstr [] = initstr
consOtherDigit _ (s:ss) =
    if s == '1'
       then '0':s:ss
       else '1':s:ss

combineMLtests (x:xs) (y:ys) = (union x y) : combineMLtests xs ys
combineMLtests xs []         = xs
combineMLtests [] ys         = ys

--------------------------------------------------
-- Example generator sets for M-L tests

-- prefix-free generators for M-L tests for infinite zeros and infinite ones
zeros          = iterate (\ss -> map ('0':) ss) [""] -- 0, 00, 000, ...
ones           = iterate (\ss -> map ('1':) ss) [""] -- 1, 11, 111, ...
terminal_zeros = [""] : iterate (\ss -> map ('1':) ss) ["0"] -- 0, 10, 110, ...
terminal_ones  = [""] : iterate (\ss -> map ('0':) ss) ["1"] -- 1, 01, 001, ... 

zero_ones = iterate (\ss -> map (consOtherDigit "0") ss) [""]
one_zeros = iterate (\ss -> map (consOtherDigit "1") ss) [""]
alternators = combineMLtests zero_ones one_zeros

zeros_or_ones = combineMLtests zeros ones
terminal_both = combineMLtests terminal_zeros terminal_ones

-- Remove the first set since it includes "", a prefix to other elements,
-- and remove the second since it includes "1", which is a prefix for "110".
multisize :: [[String]]
multisize = drop 2 (foldr combineMLtests [[]] 
                          [terminal_ones, drop 2 terminal_zeros, 
                          drop 4 terminal_ones, drop 6 zeros])

-- Note that even though there are shared prefixes, no string in any
-- generator set is a prefix of any other (since they're all the same
-- length!).
someofem = foldr combineMLtests [[]] 
                 [zeros, ones, terminal_zeros, terminal_ones, zero_ones, 
                 one_zeros]
-- don't include e.g. multisize--you'll get prefix relations


-----------------------------------------------
-- Random generation of generator sets

-- Example usage:
-- gs = removePrefixes $ take 20 $ generateGeneratorLists (System.Random.mkStdGen 524) 13
-- mt = sumGeneratorSet generators
-- isMartingaleTree $ takeTree 10 mt
-- drawTree $ takeTree 6 mt

-- System.Random uses a Steele et al. SplitMix PRNG:
-- https://hackage.haskell.org/package/random-1.2.0/docs/System-Random.html


-- |
-- Returns an unlimited number of random lists of 0's and 1's, of random 
-- length between 1 and maxLen, inclusive.  rng is an instance of RandomGen.
-- (This returns an infinite list of lists, but of course there are only
-- sum_{k=1}^n 2^k such lists, where n = maxLen.)
generateGeneratorLists :: RandomGen t => t -> Int -> [String]
generateGeneratorLists rng maxLen =
    let (rngForSeq, rngForFirstLength) = System.Random.split rng
        randSeq = randomRs (0,1) rngForSeq
        selectStrings g seq =
            let (len, g') = randomR (1, maxLen) g
            in (map intToDigit (take len seq)) : (selectStrings g' (drop len seq))
     in selectStrings rngForFirstLength randSeq

-- |
-- This is a compare function for sortBy that puts shorter lists first, and 
-- only compares contents for lists of equal length.
compareSizeFirst xs ys
  | length xs < length ys = LT
  | length xs > length ys = GT
  | otherwise = compare xs ys

-- | 
-- Given a finite list of lists sorted by size and the usual ordering,
-- removes lists that are prefixes of later lists.
removeSortedPrefixes [] = []
removeSortedPrefixes (x:xs) =
    if any (isPrefixOf x) xs
       then removeSortedPrefixes xs
       else x : removeSortedPrefixes xs
-- This is O(n^2) in number of lists, and there might be a faster way,
-- but it's OK for me.

-- | Given a finite list of lists, removes lists that are prefixes.
removePrefixes generators =
    removeSortedPrefixes (sortBy compareSizeFirst generators)
-- We sort by size because if x is longer than what follows it, it can't
-- possibly be a prefix.

